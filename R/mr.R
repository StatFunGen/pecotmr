# heterogeneity:  calculate I2 statistics based on the Cochran's Q statistic
calc_I2 = function(Q, Est) {
    Q = Q[[1]]
    Est = length(unique(Est))
    I2 = if (Q > 1e-3) (Q - Est + 1)/Q else 0
    return(if (I2 < 0) 0 else I2)
}

#' MR Format Function
#'
#' Description of what the function does.
#'
#' @param susie_result A list containing the results of SuSiE analysis. This list should include nested elements such as 'susie_results', 'susie_result_trimmed', and 'top_loci', containing details about the statistical analysis of genetic variants.
#' @param condition A character string specifying the conditions. This is used to select the corresponding subset of results within 'susie_result'.
#' @param gwas_sumstats_db A data frame containing summary statistics from GWAS studies. It should include columns for variant id and their associated statistics such as beta coefficients and standard errors.
#' @param sets A character string indicating the method used to define sets of genetic variants. Defaults to "sets". This parameter is used to specify the type of sets to extract from the 'susie_result' object.
#' @param coverage A character string specifying the coverage threshold for credible sets, used when 'sets' is not "sets". Defaults to "coverage_0.95", indicating a 95% coverage credible set.
#' @param allele_qc Optional. A logical value indicating whether allele qc should be performed on the variants. When TRUE, allele qc are applied to the variants based on the GWAS summary statistics database ('gwas_sumstats_db').
#' @return A data frame formatted for MR analysis or NULL if cs_list is empty.
#' @export
mr_format<- function(susie_result, condition, gwas_sumstats_db, sets = "sets", coverage = "coverage_0.95", allele_qc = TRUE) {
    if(sets == "sets"){
        cs_list = get_nested_element(susie_result,c("susie_results",condition, "susie_result_trimmed", sets))[["cs"]]
    } else {
        cs_list = get_nested_element(susie_result,c("susie_results",condition, "susie_result_trimmed", sets, coverage,"sets"))[["cs"]]
    }
    if (!is.null(names(cs_list))){
         coverage_column_name <- paste0("cs_",coverage,sep = "")
         susie_cs_result_formatted <- get_nested_element(susie_result,c("susie_results",condition, "top_loci"))%>%
                                      mutate(gene_name = get_nested_element(susie_result,c("susie_results",condition,"region_info","name")))%>%
                                      filter(coverage_column_name >= 1)%>%
                                      mutate(variant = ifelse(grepl("^chr[0-9]+:", variant_id), gsub("^chr", "", variant_id), variant_id))%>%
                                      select(gene_name, variant, betahat, sebetahat,all_of(coverage_column_name),pip)%>%
                                      rename("bhat_x"="betahat","sbhat_x"="sebetahat","cs" = all_of(coverage_column_name))
        if(allele_qc == TRUE){
            susie_cs_result_formatted <- allele_qc(susie_cs_result_formatted$variant, gwas_sumstats_db$variant_id,susie_cs_result_formatted,c("bhat_x","sbhat_x"))$target_data_qced[,c("gene_name","variant_id","bhat_x","sbhat_x","cs","pip")]
        }
            
        susie_cs_gwas_variants_merge <- intersect(susie_cs_result_formatted$variant, gwas_sumstats_db$variant_id)
        
        mr_format_input <- susie_cs_result_formatted[match(susie_cs_gwas_variants_merge, susie_cs_result_formatted$variant),] %>%
                             cbind(., gwas_sumstats_db[match(susie_cs_gwas_variants_merge, gwas_sumstats_db$variant_id), ] %>% 
                             select(beta, se) %>% 
                             rename("bhat_y" = "beta", "sbhat_y" = "se"))
        return(mr_format_input)                                      
        
    } else {
        gene_name = gene_name = get_nested_element(susie_result,c("susie_results",condition,"region_info","name"))
        return(NULL)
    } 
}

#' Mendelian Randomization (MR)
#' 
#' @param mr_formatted_input the output of twas_mr_format_input function
#' @param cpip_cutoff the threshold of cumulative posterior inclusion probability, default is 0.5
#' @return A single data frame of output with columns "gene_name", "num_CS", "num_IV",
#' "meta_eff", "se_meta_eff", "meta_pval", "Q", "Q_pval" and "I2". "gene_name" is ensemble ID. "num_CS" is the number of credible sets
#' contained in each gene, "num_IV" is the number of variants contained in each gene. "meta_eff", "se_meta_eff" and "meta_pval" are the MR estimate, standard error and pvalue.
#' "Q" is Cochranâ€™s Q statistic, "I2" quantifies the heterogeneity, range from 0 to 1.
#' @import dplyr
#' @importFrom stats pnorm
#' @export
mr_analysis <- function(mr_formatted_input, cpip_cutoff=0.5) {
    if(is.null(mr_formatted_input)){
       output<- NULL
    } else {
       output = mr_formatted_input %>%
                mutate(
                       bhat_x = bhat_x/sbhat_x,
                       sbhat_x = 1) %>%
                group_by(gene_name,cs) %>%
                mutate(cpip = sum(pip)) %>%
                filter(cpip >= cpip_cutoff) # Cumulative pip greater than a user defined cumulative pip threshold
    }
    if(dim(output)[1]==0){
        output<- NULL
    } else {
        output = output %>% 
                group_by(gene_name, cs) %>%
                mutate(
                      beta_yx = bhat_y/bhat_x,
                      se_yx = sqrt((sbhat_y^2/bhat_x^2) + ((bhat_y^2*sbhat_x^2)/bhat_x^4)),
                      composite_bhat = sum((beta_yx*pip)/cpip),
                      composite_sbhat = sum((beta_yx^2 + se_yx^2)*pip/cpip)) %>%
                mutate(
                      composite_sbhat = sqrt(composite_sbhat - composite_bhat^2),
                      wv = composite_sbhat^-2) %>%
                      ungroup() %>%
                mutate(
                     meta_eff = sum(unique(wv) * unique(composite_bhat)),
                     sum_w = sum(unique(wv)),
                     se_meta_eff = sqrt(sum_w^-1),
                     num_CS = length(unique(cs))) %>%
                mutate(
                     num_IV = length(variant_id),
                     meta_eff = meta_eff/sum_w,
                     meta_pval = 2 * pnorm(abs(meta_eff) / se_meta_eff, lower.tail=FALSE),
                     Q = sum(unique(wv)*(unique(composite_bhat) - unique(meta_eff))^2),
                     I2 = calc_I2(Q, composite_bhat),
                     Q_pval = pchisq(Q, df = length(unique(composite_bhat))-1, lower = F)) %>%
                ungroup() %>%
                distinct(gene_name, .keep_all = TRUE) %>%
                mutate(
                    cpip = round(cpip, 3),
                    meta_pval= round(meta_pval,3),
                    meta_eff = round(meta_eff, 3),
                    se_meta_eff = round(se_meta_eff, 3),
                    Q = round(Q, 3),
                    Q_pval = round(Q_pval,3),
                    I2 = round(I2, 3)) %>%arrange(meta_pval)%>%
                select(gene_name, num_CS, num_IV, cpip, meta_eff, se_meta_eff, meta_pval, Q, Q_pval,I2)
    }
    output
}